<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>India Railway Router Â· Start â†’ End on Tracks</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <style>
    #map { height: 100vh; }
    .controls {
      position: absolute;
      z-index: 1000;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.95);
      padding: 10px;
      border-radius: 6px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.15);
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .controls select, .controls button {
      font-size: 14px;
      padding: 6px 8px;
    }
    .status {
      position: absolute;
      z-index: 1000;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 8px 10px;
      border-radius: 6px;
      font-family: system-ui, Arial, sans-serif;
      font-size: 13px;
      max-width: 50ch;
    }
    .train-icon { font-size: 20px; }
    .legend {
      position: absolute;
      z-index: 1000;
      top: 10px;
      right: 10px;
      background: rgba(255,255,255,0.95);
      padding: 8px 10px;
      border-radius: 6px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.15);
      font-family: system-ui, Arial, sans-serif;
      font-size: 12px;
      max-height: 35vh;
      overflow: auto;
    }
    .legend .item { display: flex; align-items: center; gap: 6px; margin: 2px 0; }
    .legend .swatch { width: 12px; height: 12px; border-radius: 2px; border: 1px solid #0002; }
  </style>
</head>
<body>
  <!-- Simple toggle for train visibility -->
  <div class="controls">
    <label style="display:flex; align-items:center; gap:6px;">
      <input id="toggleTrains" type="checkbox" checked />
      <span>Show trains</span>
    </label>
  </div>
  <div id="map"></div>
  <div class="status" id="status">Loading railway networkâ€¦</div>
  <div id="performance" style="position: absolute; top: 60px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 8px; border-radius: 4px; font-size: 12px; z-index: 1000;">
    <div>FPS: <span id="fps">--</span></div>
    <div>Trains: <span id="trainCount">--</span></div>
  </div>
  <div class="legend" id="legend" hidden>
    <div><strong>Scheduled Trains</strong></div>
    <div id="legendItems"></div>
  </div>

  <script>
    // Initialize map centered on India
    const map = L.map('map').setView([22.8, 79.5], 5);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

  // Layers and global state
    let railwayLayer = null;
    let stationLayer = null;
    const realtimeLayer = L.layerGroup().addTo(map); // holds realtime train markers
    const stationIndex = new Map(); // name -> {lat, lng}
  const stationIndexCi = new Map(); // lowercased name -> {lat, lng}

    // Graph of railway vertices
    const graph = new Map(); // key -> { lat, lng, neighbors: Map(key, distanceKm) }
    const nodeKeys = []; // list of keys for iteration
    const keyOf = (lat, lng) => `${lat.toFixed(5)},${lng.toFixed(5)}`; // dedupe tolerance ~1m-10m

    const toLatLng = (coord) => [coord[1], coord[0]]; // [lng, lat] -> [lat, lng]

    // Optimized distance calculation with caching
    const distanceCache = new Map();
    function haversineKm(lat1, lon1, lat2, lon2) {
      const cacheKey = `${lat1.toFixed(4)},${lon1.toFixed(4)},${lat2.toFixed(4)},${lon2.toFixed(4)}`;
      if (distanceCache.has(cacheKey)) return distanceCache.get(cacheKey);
      
      const R = 6371;
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      const result = 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      distanceCache.set(cacheKey, result);
      return result;
    }

    function ensureNode(lat, lng) {
      const k = keyOf(lat, lng);
      if (!graph.has(k)) {
        graph.set(k, { lat, lng, neighbors: new Map() });
        nodeKeys.push(k);
      }
      return graph.get(k);
    }

    function addEdge(lat1, lng1, lat2, lng2) {
      const n1 = ensureNode(lat1, lng1);
      const n2 = ensureNode(lat2, lng2);
      const k1 = keyOf(lat1, lng1);
      const k2 = keyOf(lat2, lng2);
      const d = haversineKm(lat1, lng1, lat2, lng2);
      const setMin = (from, to, dist) => {
        const cur = from.neighbors.get(to);
        if (cur === undefined || dist < cur) from.neighbors.set(to, dist);
      };
      setMin(n1, k2, d);
      setMin(n2, k1, d);
    }

    function findNearestNode(lat, lng) {
      let bestKey = null;
      let bestDist = Infinity;
      for (const k of nodeKeys) {
        const n = graph.get(k);
        const d = haversineKm(lat, lng, n.lat, n.lng);
        if (d < bestDist) {
          bestDist = d;
          bestKey = k;
        }
      }
      return { key: bestKey, distKm: bestDist };
    }

    // Snap a lat/lng to nearest graph node within a threshold (km); if none within threshold, return original
    function snapLatLngToTrack(lat, lng, maxKm = 2) {
      if (!nodeKeys.length) return { lat, lng };
      const { key, distKm } = findNearestNode(lat, lng);
      if (!key || distKm == null || distKm > maxKm) return { lat, lng };
      const n = graph.get(key);
      return { lat: n.lat, lng: n.lng };
    }

    // Enhanced snapping for better track alignment
    function snapToTrackStrict(lat, lng) {
      const result = snapLatLngToTrack(lat, lng, 8); // Larger search radius
      // If still far from track, try a more aggressive search
      if (!nodeKeys.length) return { lat, lng };
      const { distKm } = findNearestNode(result.lat, result.lng);
      if (distKm > 1) {
        // Try finding nearest track with larger radius
        return snapLatLngToTrack(lat, lng, 15);
      }
      return result;
    }

    // Min-heap priority queue for Dijkstra
    class MinHeap {
      constructor() { this.a = []; }
      push(item) { this.a.push(item); this.bubbleUp(this.a.length - 1); }
      bubbleUp(i) {
        while (i > 0) {
          const p = Math.floor((i - 1) / 2);
          if (this.a[p][0] <= this.a[i][0]) break;
          [this.a[p], this.a[i]] = [this.a[i], this.a[p]]; i = p;
        }
      }
      pop() {
        if (this.a.length === 0) return undefined;
        const top = this.a[0];
        const end = this.a.pop();
        if (this.a.length > 0) { this.a[0] = end; this.sinkDown(0); }
        return top;
      }
      sinkDown(i) {
        const n = this.a.length;
        while (true) {
          let l = 2*i + 1, r = 2*i + 2, s = i;
          if (l < n && this.a[l][0] < this.a[s][0]) s = l;
          if (r < n && this.a[r][0] < this.a[s][0]) s = r;
          if (s === i) break;
          [this.a[i], this.a[s]] = [this.a[s], this.a[i]]; i = s;
        }
      }
      get length() { return this.a.length; }
    }

    function dijkstra(startKey, endKey) {
      const dist = new Map();
      const prev = new Map();
      const heap = new MinHeap();
      for (const k of nodeKeys) dist.set(k, Infinity);
      dist.set(startKey, 0);
      heap.push([0, startKey]);
      const visited = new Set();

      while (heap.length) {
        const [d, u] = heap.pop();
        if (visited.has(u)) continue;
        visited.add(u);
        if (u === endKey) break;
        const uNode = graph.get(u);
        for (const [v, w] of uNode.neighbors) {
          const nd = d + w;
          if (nd < dist.get(v)) {
            dist.set(v, nd);
            prev.set(v, u);
            heap.push([nd, v]);
          }
        }
      }

      if (!prev.has(endKey) && startKey !== endKey) return null;
      // Reconstruct path
      const path = [];
      let cur = endKey;
      path.push(cur);
      while (cur !== startKey) {
        const p = prev.get(cur);
        if (!p) break; // start==end or no path
        path.push(p);
        cur = p;
      }
      path.reverse();
      return path;
    }

    // Turn-constrained Dijkstra (minimum turn): state = (prevKey, curKey); reject transitions with turn < minTurnDeg at cur
    function dijkstraTurnMin(startKey, endKey, minTurnDeg) {
      const stateKey = (prev, cur) => `${prev ?? ''}->${cur}`;
      const dist = new Map(); // stateKey -> distance
      const prevState = new Map(); // stateKey -> prior stateKey
      const heap = new MinHeap(); // [dist, prevKey, curKey]
      const visited = new Set(); // stateKey

      // Seed with a virtual start state (null -> start), expand to neighbors without angle check
      const seedKey = stateKey(null, startKey);
      dist.set(seedKey, 0);
      heap.push([0, null, startKey]);

      // Best end state encountered (any prev -> endKey)
      let bestEndState = null;
      let bestEndDist = Infinity;

      while (heap.length) {
        const [d, prevK, curK] = heap.pop();
        const sk = stateKey(prevK, curK);
        if (visited.has(sk)) continue;
        visited.add(sk);
        if (curK === endKey && d < bestEndDist) {
          bestEndDist = d;
          bestEndState = sk;
          // Don't break; there might be an even shorter path via different prev
        }
        const curNode = graph.get(curK);
        if (!curNode) continue;
        for (const [nextK, w] of curNode.neighbors) {
          // Enforce turn at cur for transition prevK -> curK -> nextK
          if (prevK) {
            const A = graph.get(prevK);
            const B = curNode;
            const C = graph.get(nextK);
            if (!A || !B || !C) continue;
            const ang = turnAngleDeg({lat:A.lat,lng:A.lng}, {lat:B.lat,lng:B.lng}, {lat:C.lat,lng:C.lng});
            if (ang < minTurnDeg) continue; // too shallow, skip
          }
          const nd = d + w;
          const nsk = stateKey(curK, nextK);
          if (nd < (dist.get(nsk) ?? Infinity)) {
            dist.set(nsk, nd);
            prevState.set(nsk, sk);
            heap.push([nd, curK, nextK]);
          }
        }
      }

      if (!bestEndState) return null;
      // Reconstruct path of node keys by following states' cur node back to start
      const pathKeys = [];
      let sk = bestEndState;
      // Collect last state's cur node first
      const parseSk = (s) => {
        const [p, c] = s.split('->');
        return { prev: p || null, cur: c };
      };
      while (sk) {
        const { prev, cur } = parseSk(sk);
        pathKeys.push(cur);
        sk = prevState.get(sk) || null;
        if (!sk) {
          // Add the start node if not already present
          if (prev) pathKeys.push(prev);
        }
      }
      pathKeys.reverse();
      return pathKeys;
    }

    // UI elements (simplified - only status and train toggle remain)
    const statusEl = document.getElementById('status');

  // Removed manual train animation - using optimized simulation only

  // Scheduled trains (multiple)
  const scheduledTrains = new Map(); // id -> state
  let scheduledAnimTimer = null;
  let scheduledPaused = false;
  let schedulesLoaded = false;
  const legendEl = document.getElementById('legend');
  const legendItemsEl = document.getElementById('legendItems');
  // Single-track occupancy (undirected edge between two nodes)
  const trackOccupancy = new Map(); // edgeKey -> trainId
  const edgeKeyOf = (k1, k2) => {
    const a = String(k1), b = String(k2);
    return a < b ? `${a}|${b}` : `${b}|${a}`;
  };
  function tryAcquireEdge(trainId, edgeKey) {
    const holder = trackOccupancy.get(edgeKey);
    if (!holder) { trackOccupancy.set(edgeKey, trainId); return true; }
    return holder === trainId;
  }
  function releaseEdge(trainId, edgeKey) {
    const holder = trackOccupancy.get(edgeKey);
    if (holder === trainId) trackOccupancy.delete(edgeKey);
  }

    // Zoom-based visibility: show markers only when zoomed in enough
    const markerVisibilityZoom = 4; // Visible from default zoom for better simulation
    const stationVisibilityZoom = 12; // Much higher zoom required to see stations (avoid clutter)
  // Visualization toggle: keep only station markers visible on map
      let showTrainMarkers = true; // default visible for main simulation

      function applyTrainMarkerVisibility() {
        // Scheduled trains
        for (const t of scheduledTrains.values()) {
          if (!t.marker) continue;
          if (showTrainMarkers) {
            if (!map.hasLayer(t.marker)) t.marker.addTo(map);
            const show = map.getZoom() >= markerVisibilityZoom && !!t.started;
            t.marker.setOpacity(show ? 1 : 0);
          } else {
            if (map.hasLayer(t.marker)) map.removeLayer(t.marker);
          }
        }
        // Realtime markers (including simulation markers added to realtimeLayer)
        realtimeLayer.eachLayer(layer => {
          if (showTrainMarkers) {
            if (!map.hasLayer(realtimeLayer)) realtimeLayer.addTo(map);
            setMarkerVisible(layer, map.getZoom() >= markerVisibilityZoom);
          } else {
            if (map.hasLayer(realtimeLayer)) map.removeLayer(realtimeLayer);
          }
        });
      }
    function setMarkerVisible(marker, visible) {
      if (!marker) return;
      marker.setOpacity(visible ? 1 : 0);
      if (marker.getTooltip && marker.getTooltip()) {
        if (visible) marker.openTooltip(); else marker.closeTooltip();
      }
    }
    function updateVisibilityForZoom() {
      const showTrains = map.getZoom() >= markerVisibilityZoom;
      const showStations = map.getZoom() >= stationVisibilityZoom;
      // Keep station layer on the map; but only show when zoomed in very close
      if (stationLayer) {
        if (!map.hasLayer(stationLayer)) stationLayer.addTo(map);
        stationLayer.eachLayer(l => { if (l.setStyle) l.setStyle({ opacity: showStations ? 1 : 0, fillOpacity: showStations ? 0.6 : 0 }); });
      }
      // Toggle realtime markers opacity
      if (showTrainMarkers) {
        realtimeLayer.eachLayer(layer => setMarkerVisible(layer, showTrains));
      }
      // Toggle scheduled markers opacity  
      for (const t of scheduledTrains.values()) {
        if (!t.marker) continue;
        if (showTrainMarkers) {
          const visible = showTrains && !!t.started; // hide if not started
          setMarkerVisible(t.marker, visible);
        }
      }
    }
    map.on('zoomend', updateVisibilityForZoom);
    const toggleTrainsEl = document.getElementById('toggleTrains');
    if (toggleTrainsEl) {
      toggleTrainsEl.checked = showTrainMarkers;
      toggleTrainsEl.addEventListener('change', () => {
        showTrainMarkers = !!toggleTrainsEl.checked;
        applyTrainMarkerVisibility();
        console.log(`Train markers ${showTrainMarkers ? 'enabled' : 'disabled'}`);
      });
    }

    // Geometry helpers for realistic turning
    function bearingDeg(p1, p2) {
      const y = (p2.lng - p1.lng);
      const x = (p2.lat - p1.lat);
      const ang = Math.atan2(y, x) * 180 / Math.PI; // rough planar
      return (ang + 360) % 360;
    }
    function turnAngleDeg(a, b, c) {
      const br1 = bearingDeg(b, a);
      const br2 = bearingDeg(b, c);
      let d = Math.abs(br2 - br1);
      if (d > 180) d = 360 - d;
      return d; // 0 straight, 180 U-turn
    }

    function setStatus(msg) { statusEl.textContent = msg; }

    // Removed UI control functions and station popups - using map-only interface

    function populateStationIndex(features) {
      // Just populate the station index for internal use (no UI selects)
      for (const f of features) {
        const name = f.properties && (f.properties.name ?? f.properties['name:en'] ?? f.properties['Name']);
        if (!name) continue;
        const [lng, lat] = f.geometry.coordinates;
        const rec = { lat, lng };
        stationIndex.set(name, rec);
        stationIndexCi.set(name.toLowerCase().trim(), rec);
      }
    }

    function buildGraphFromGeoJSON(data) {
      let lineCount = 0, edgeCount = 0;
      const addLine = (coords) => {
        for (let i = 0; i < coords.length - 1; i++) {
          const [lng1, lat1] = coords[i];
          const [lng2, lat2] = coords[i+1];
          addEdge(lat1, lng1, lat2, lng2);
          edgeCount++;
        }
        lineCount++;
      };
      for (const f of data.features) {
        const g = f.geometry;
        if (!g) continue;
        if (g.type === 'LineString') addLine(g.coordinates);
        else if (g.type === 'MultiLineString') {
          for (const part of g.coordinates) addLine(part);
        }
      }
      return { lineCount, edgeCount, nodeCount: nodeKeys.length };
    }

    // ===== Sample routes-based routing (sample_train_routes.json) =====
    // All routing now uses the loaded sample routes data

    function resolveStationName(name) {
      if (!name) return null;
      const direct = stationIndex.get(name) || stationIndexCi.get(String(name).toLowerCase().trim());
      if (direct) return direct;
      // Fallback: fuzzy includes match (case-insensitive)
      const needle = String(name).toLowerCase().trim();
      let best = null;
      let bestScore = -Infinity;
      for (const [key, rec] of stationIndex.entries()) {
        const hay = key.toLowerCase();
        if (hay === needle) return rec;
        // score: prefer includes with longer common length and shorter total length difference
        if (hay.includes(needle) || needle.includes(hay)) {
          const common = Math.min(hay.length, needle.length);
          const diff = Math.abs(hay.length - needle.length);
          const score = common * 2 - diff; // heuristic
          if (score > bestScore) { bestScore = score; best = rec; }
        }
      }
      return best;
    }

    function computeRoute(startName, endName) {
      // Use sample routes data: find a route connecting these stations
      if (!sampleSimRoutes || !sampleSimRoutes.length) {
        console.warn('No sample routes loaded for routing');
        return null;
      }
      
      const fromRec = resolveStationName(startName);
      const toRec = resolveStationName(endName);
      if (!fromRec || !toRec) return null;
      
      // Find a route that passes near both stations
      for (const route of sampleSimRoutes) {
        if (!route.coords || route.coords.length < 2) continue;
        
        let nearStart = -1, nearEnd = -1;
        const tolerance = 50; // km tolerance for station matching
        
        for (let i = 0; i < route.coords.length; i++) {
          const [lat, lng] = route.coords[i];
          const distToStart = haversineKm(lat, lng, fromRec.lat, fromRec.lng);
          const distToEnd = haversineKm(lat, lng, toRec.lat, toRec.lng);
          
          if (nearStart === -1 && distToStart <= tolerance) nearStart = i;
          if (distToEnd <= tolerance) nearEnd = i;
        }
        
        if (nearStart >= 0 && nearEnd > nearStart) {
          // Return the segment from nearStart to nearEnd
          const segment = route.coords.slice(nearStart, nearEnd + 1);
          return segment; // Already in [lat, lng] format
        }
      }
      
      // Fallback: direct line between stations
      return [[fromRec.lat, fromRec.lng], [toRec.lat, toRec.lng]];
    }

    // Also return node keys so we can manage single-track occupancy
    function computeRouteWithKeys(startName, endName) {
      const latlngs = computeRoute(startName, endName);
      if (!latlngs || latlngs.length < 2) return null;
      // Convert to object format expected by caller
      return { keys: null, latlngs: latlngs.map(p => ({ lat: p[0], lng: p[1] })) };
    }

    // Removed startAnimation - using optimized train simulation only

    // Utilities for scheduled trains
    function colorForId(id) {
      // Simple hash to HSL color
      let h = 0;
      const s = String(id);
      for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) >>> 0;
      return `hsl(${h % 360} 85% 45%)`;
    }

    // Forgiving JSON parser: handles BOM, comments, trailing commas, and NDJSON fallback
    function parseJsonLoose(text) {
      if (typeof text !== 'string') return text;
      const stripBOM = (t) => t.replace(/^\uFEFF/, '');
      let t = stripBOM(text);
      // First attempt
      try { return JSON.parse(t); } catch (e1) {
        console.warn('Initial JSON parse failed, trying fixes:', e1.message);
        // Remove /* */ and // comments
        try {
          const noBlock = t.replace(/\/\*[\s\S]*?\*\//g, '');
          const noLine = noBlock.replace(/(^|[^:])\/\/.*$/gm, '$1');
          // Remove trailing commas before } or ]
          const noTrailing = noLine.replace(/,\s*([}\]])/g, '$1');
          return JSON.parse(noTrailing);
        } catch (e2) {
          console.warn('Comment removal failed, trying NDJSON:', e2.message);
          // NDJSON fallback: parse per line
          try {
            const lines = t.split(/\r?\n/).map(l => l.trim()).filter(l => l && !l.startsWith('//'));
            const arr = [];
            for (const line of lines) {
              try { arr.push(JSON.parse(line)); } catch (e) { /* skip bad lines */ }
            }
            return arr.length > 0 ? arr : null;
          } catch (e3) {
            console.error('All JSON parsing attempts failed for text length:', t.length, 'Error:', e3.message);
            return null;
          }
        }
      }
    }

    function parseDepartOffsetMs(val) {
      const now = new Date();
      if (typeof val === 'number' && isFinite(val)) {
        // minutes from now
        return Math.max(0, Math.round(val * 60 * 1000));
      }
      if (typeof val === 'string') {
        // Try ISO or HH:MM[:SS]
        if (/^\d{2}:\d{2}(:\d{2})?$/.test(val)) {
          const [hh, mm, ss] = val.split(':').map(Number);
          const when = new Date(now);
          when.setHours(hh, mm, ss || 0, 0);
          let off = when.getTime() - now.getTime();
          if (off < 0) off += 24 * 60 * 60 * 1000; // next day
          return off;
        }
        const dt = new Date(val);
        if (!isNaN(dt.getTime())) {
          return Math.max(0, dt.getTime() - now.getTime());
        }
      }
      return 0;
    }

    function addLegendItem(id, color, label) {
      const div = document.createElement('div');
      div.className = 'item';
      const sw = document.createElement('span');
      sw.className = 'swatch';
      sw.style.background = color;
      const txt = document.createElement('span');
      txt.textContent = label || String(id);
      div.appendChild(sw); div.appendChild(txt);
      legendItemsEl.appendChild(div);
      legendEl.hidden = false;
    }

    function createScheduledTrain(entry) {
      const id = entry.id ?? entry.trainId ?? entry.name ?? `T${scheduledTrains.size + 1}`;
      const from = entry.from ?? entry.start ?? entry.source ?? entry.startStation;
      const to = entry.to ?? entry.end ?? entry.destination ?? entry.endStation;
      if (!from || !to) {
        console.warn('Schedule missing from/to:', entry);
        return null;
      }
      const routeObj = computeRouteWithKeys(from, to);
      if (!routeObj || !routeObj.latlngs || routeObj.latlngs.length < 2) {
        console.warn(`No route for ${id} from ${from} to ${to}`);
        return null;
      }
      const color = entry.color || colorForId(id);
      const speed = Number(entry.speedKmh ?? entry.speed ?? 80);
      const startNowEl = document.getElementById('startNow');
      const startNow = startNowEl ? !!startNowEl.checked : true;
      const departMs = startNow ? 0 : parseDepartOffsetMs(entry.depart ?? entry.departAt ?? entry.departure ?? entry.departureTime ?? 0);
      const latlngObjs = routeObj.latlngs;

      // Optimized polyline rendering - only for small numbers and high zoom
      const shouldShowLine = trainRoutes.length < 30 && map.getZoom() > 6;
      const line = shouldShowLine ? 
        L.polyline(latlngObjs, { color, weight: 1.5, opacity: 0.6 }).addTo(map) : 
        null;
      const icon = L.divIcon({ className: 'train-icon', html: 'ðŸš†', iconSize: [22,22] });
  const marker = L.marker(latlngObjs[0], { icon });
  if (showTrainMarkers) marker.addTo(map);
      marker.bindTooltip(String(id), { permanent: true, direction: 'top', offset: [0, -10], className: 'train-label' });
      // Hide until departure, unless starting immediately
      const visible = (departMs === 0) && (map.getZoom() >= markerVisibilityZoom);
      marker.setOpacity(visible ? 1 : 0);

      const state = {
        id, color, from, to, speedKmh: speed,
        latlngs: latlngObjs,
        keys: routeObj.keys,
        segIndex: 0,
        segOffsetKm: 0,
        marker, line,
        started: departMs === 0,
        completed: false,
        departAt: Date.now() + departMs,
        blockedAtNode: false,
        heldEdgeKey: null,
        turnResumeAt: null,
        turnSlowTicks: 0,
        waitEdgeFromIdx: null,
        pauseNodeIdx: null,
        externalUntil: null,
        externalControlled: false,
      };
      scheduledTrains.set(id, state);
      addLegendItem(id, color, `${id}: ${from} â†’ ${to}`);
      return state;
    }

    function normalizeSchedulesJson(json) {
      if (Array.isArray(json)) return json;
      if (!json || typeof json !== 'object') return [];
      const known = json.schedules || json.trains || json.entries || json.train_schedules || json.train_schedule || json.data || json.items || json.rows || [];
      if (Array.isArray(known) && known.length) return known;
      // Fallback: pick the longest array-valued property
      let best = [];
      for (const [k, v] of Object.entries(json)) {
        if (Array.isArray(v) && v.length > best.length) best = v;
      }
      return best;
    }

    // Convert various entry shapes into simple trips {id, name, from, to, depart?}
    function deriveTripsFromEntries(entries) {
      if (!Array.isArray(entries)) return [];
      // Case 1: already trips with from/to
      const hasFromTo = entries.some(e => e && (e.from || e.start || e.source || e.startStation) && (e.to || e.end || e.destination || e.endStation));
      if (hasFromTo) return entries;
      const trips = [];
      // Case 2: train objects with Route arrays (your sample)
      const trainsWithRoute = entries.filter(e => e && Array.isArray(e.Route) && e.Route.length > 0);
      if (trainsWithRoute.length) {
        for (const t of trainsWithRoute) {
          const id = t['Train No'] ?? t.train_no ?? t.trainNo ?? t.id ?? t.trainId ?? t['TrainNo'];
          const name = t['Train Name'] ?? t.train_name ?? t.name;
          const stops = t.Route.slice().sort((a,b) => (Number(a.SEQ ?? a.seq ?? a.order ?? 0) - Number(b.SEQ ?? b.seq ?? b.order ?? 0)));
          const first = stops[0];
          const last = stops[stops.length - 1];
          const getStopName = (s) => s && (s['Station Name'] ?? s.station_name ?? s.stationName ?? s.station ?? s['Station']);
          const from = getStopName(first) || t['Source Station Name'] || t.source || t.sourceStation;
          const to = getStopName(last) || t['Destination Station Name'] || t.destination || t.destinationStation;
          const depart = first && (first['Departure Time'] ?? first['Arrival time'] ?? first.departure_time ?? first.arrival_time);
          if (from && to) {
            trips.push({ id, name, from, to, ...(depart ? { depart } : {}) });
          }
        }
        if (trips.length) return trips;
      }
      // Case 3: Unknown structure; pass through
      return entries;
    }

    function createTrainsFromEntries(entries, fit = true) {
      const useEntries = deriveTripsFromEntries(entries);
      let created = 0;
      const bounds = L.latLngBounds([]);
      for (const e of useEntries) {
        const t = createScheduledTrain(e);
        if (t) {
          created++;
          t.latlngs.forEach(p => bounds.extend([p.lat, p.lng]));
        }
      }
      if (created > 0) {
        schedulesLoaded = true;
        btnPause.disabled = false;
        btnReset.disabled = false;
        startScheduledLoop();
        if (fit && bounds.isValid()) map.fitBounds(bounds, { padding: [30,30] });
        setStatus(`Loaded ${created} scheduled train${created>1?'s':''}.`);
      } else {
        setStatus('No valid scheduled trains to show.');
      }
      return created;
    }

    function startScheduledLoop() {
      if (scheduledAnimTimer) return;
      const kmPerTickByTrain = (t) => t.speedKmh * (tickMs / 3600000);
      let statusUpdateCounter = 0;
      scheduledAnimTimer = setInterval(() => {
        if (scheduledPaused) return;
        const now = Date.now();
        let activeCount = 0, doneCount = 0, notStarted = 0;
        for (const t of scheduledTrains.values()) {
          if (t.completed) { doneCount++; continue; }
          if (!t.started) {
            if (now >= t.departAt) {
              t.started = true;
              if (showTrainMarkers) t.marker.setOpacity(map.getZoom() >= markerVisibilityZoom ? 1 : 0);
            } else {
              notStarted++;
              continue; // not started yet
            }
          }
          // If realtime is driving this train, keep marker at realtime position until external data goes stale
          if (t.externalControlled) {
            if (t.externalUntil && now < t.externalUntil) {
              // Do not advance along scheduled route while under external control
              continue;
            } else {
              // External data stale; relinquish external control
              t.externalControlled = false;
              t.externalUntil = null;
            }
          }
          activeCount++;
          if (t.segIndex >= t.latlngs.length - 1) { t.completed = true; continue; }
          // Handle node blocking (waiting for lock or turn dwell)
          if (t.blockedAtNode) {
            const nodeIdx = Math.min(t.segIndex, t.latlngs.length - 1);
            if (t.turnResumeAt && now < t.turnResumeAt) {
              const pos = t.latlngs[nodeIdx];
              if (showTrainMarkers) {
                const snapped = snapLatLngToTrack(pos.lat, pos.lng, 5);
                t.marker.setLatLng([snapped.lat, snapped.lng]);
              }
              continue;
            }
            if (t.turnResumeAt && now >= t.turnResumeAt) {
              t.turnResumeAt = null;
            }
            // Try to acquire outgoing edge
            if (t.keys && t.keys.length > t.segIndex + 1) {
              const ek = edgeKeyOf(t.keys[t.segIndex], t.keys[t.segIndex + 1]);
              if (tryAcquireEdge(t.id, ek)) {
                t.heldEdgeKey = ek;
                t.blockedAtNode = false;
                t.segOffsetKm = 0;
              } else {
                const pos = t.latlngs[nodeIdx];
                if (showTrainMarkers) {
                  const snapped = snapLatLngToTrack(pos.lat, pos.lng, 5);
                  t.marker.setLatLng([snapped.lat, snapped.lng]);
                }
                continue;
              }
            } else {
              t.completed = true; continue;
            }
          }
          const a = t.latlngs[t.segIndex];
          const b = t.latlngs[t.segIndex + 1];
          const segKm = haversineKm(a.lat, a.lng, b.lat, b.lng);
          if (segKm === 0) { 
            t.segIndex++; 
            t.segOffsetKm = 0; 
            if (showTrainMarkers) {
              const snapped = snapLatLngToTrack(b.lat, b.lng, 5);
              t.marker.setLatLng([snapped.lat, snapped.lng]);
            }
            continue; 
          }
          // Ensure we hold the current edge before moving into it
          if (t.keys && t.keys.length > t.segIndex + 1) {
            const curEk = edgeKeyOf(t.keys[t.segIndex], t.keys[t.segIndex + 1]);
            if (!t.heldEdgeKey || t.heldEdgeKey !== curEk) {
              if (tryAcquireEdge(t.id, curEk)) {
                t.heldEdgeKey = curEk;
              } else {
                // Cannot enter edge, wait at node a
                t.blockedAtNode = true;
                t.segOffsetKm = 0;
                if (showTrainMarkers) {
                  const snapped = snapLatLngToTrack(a.lat, a.lng, 5);
                  t.marker.setLatLng([snapped.lat, snapped.lng]);
                }
                continue;
              }
            }
          }
          const kmStep = kmPerTickByTrain(t) * (t.turnSlowTicks > 0 ? 0.4 : 1);
          if (t.turnSlowTicks > 0) t.turnSlowTicks--;
          t.segOffsetKm += kmStep;
          if (t.segOffsetKm >= segKm) {
            // Arrived at node b
            if (showTrainMarkers) {
              const snapped = snapLatLngToTrack(b.lat, b.lng, 5);
              t.marker.setLatLng([snapped.lat, snapped.lng]);
            }
            // Release current edge lock at node arrival
            if (t.heldEdgeKey) { releaseEdge(t.id, t.heldEdgeKey); t.heldEdgeKey = null; }
            const nextStartIdx = t.segIndex + 1;
            if (nextStartIdx >= t.keys.length - 1) {
              t.segIndex = nextStartIdx;
              t.segOffsetKm = 0;
              t.completed = true;
              continue;
            }
            // Assess turn sharpness; if sharp, dwell briefly and slow after
            const prevIdx = Math.max(0, t.segIndex - 1);
            const A = t.latlngs[prevIdx];
            const B = t.latlngs[nextStartIdx];
            const C = t.latlngs[nextStartIdx + 1];
            let sharp = false;
            if (A && B && C) {
              const ang = turnAngleDeg(A, B, C);
              sharp = ang > 120; // threshold
            }
            // Move index to start of next edge and try to acquire
            t.segIndex = nextStartIdx;
            t.segOffsetKm = 0;
            const nextEk = edgeKeyOf(t.keys[nextStartIdx], t.keys[nextStartIdx + 1]);
            if (tryAcquireEdge(t.id, nextEk)) {
              t.heldEdgeKey = nextEk;
              if (sharp) {
                t.blockedAtNode = true;
                t.turnResumeAt = now + 300;
                t.turnSlowTicks = 3;
              }
            } else {
              t.blockedAtNode = true;
            }
          } else {
            const ratio = t.segOffsetKm / segKm;
            const lat = a.lat + (b.lat - a.lat) * ratio;
            const lng = a.lng + (b.lng - a.lng) * ratio;
            // Snap interpolated position to nearest track node to keep train on railway network
            const snapped = snapLatLngToTrack(lat, lng, 5);
            if (showTrainMarkers) t.marker.setLatLng([snapped.lat, snapped.lng]);
          }
        }
        // Update status every 5 seconds instead of every tick
        statusUpdateCounter++;
        if ((activeCount + doneCount + notStarted) > 0 && statusUpdateCounter % 5 === 0) {
          setStatus(`Scheduled trains: active ${activeCount}, waiting ${notStarted}, completed ${doneCount}, total ${scheduledTrains.size}`);
        }
      }, tickMs);
    }

    function resetScheduled() {
      if (scheduledAnimTimer) { clearInterval(scheduledAnimTimer); scheduledAnimTimer = null; }
      for (const t of scheduledTrains.values()) {
        if (t.marker) map.removeLayer(t.marker);
        if (t.line) map.removeLayer(t.line);
        if (t.heldEdgeKey) releaseEdge(t.id, t.heldEdgeKey);
      }
      scheduledTrains.clear();
      legendItemsEl.innerHTML = '';
      legendEl.hidden = true;
      scheduledPaused = false;
      schedulesLoaded = false;
      trackOccupancy.clear();
    }

    // Removed loadSchedulesIfAvailable - using optimized_trains.json only

    // Removed button event listeners - using map-only interface
    // Load railway tracks and build graph
    const railwayReady = fetch('Railways_indian.geojson').then(r => r.json()).then(data => {
      railwayLayer = L.geoJSON(data, { style: { color: '#1e88e5', weight: 0.5, opacity: 0.6 } }).addTo(map);
      const stats = buildGraphFromGeoJSON(data);
      setStatus(`Railway loaded: ${stats.nodeCount.toLocaleString()} nodes, ${stats.edgeCount.toLocaleString()} edges.`);
    }).catch(err => {
      console.error(err); setStatus('Failed to load Railways_indian.geojson');
    });

    // Load stations and populate selects + map (supports GeoJSON and JSON array formats)
    function toNumber(v) { const n = Number(v); return isFinite(n) ? n : null; }
    function makeFeaturesFromArray(arr) {
      const guessName = (o) => (o.name ?? o.Name ?? o.station ?? o["Station"] ?? o["Station Name"] ?? o.station_name ?? o.stationName ?? o.title ?? o.label);
      const guessLat = (o) => toNumber(o.lat ?? o.latitude ?? o.Latitude ?? o.LAT ?? o.y ?? o["Lat"]);
      const guessLng = (o) => toNumber(o.lng ?? o.lon ?? o.longitude ?? o.Longitude ?? o.LONG ?? o.x ?? o["Lon"] ?? o["Long"]);
      const feats = [];
      for (const o of arr) {
        const name = guessName(o); const lat = guessLat(o); const lng = guessLng(o);
        if (name && lat != null && lng != null) feats.push({ type: 'Feature', geometry: { type: 'Point', coordinates: [lng, lat] }, properties: { name } });
      }
      return { type: 'FeatureCollection', features: feats };
    }
    function loadStationsFromGeoJSON(url) {
      return fetch(url).then(r => { if (!r.ok) throw new Error('not found'); return r.json(); }).then(data => {
        if (!data || !Array.isArray(data.features)) throw new Error('bad geojson');
        if (stationLayer) { if (map.hasLayer(stationLayer)) map.removeLayer(stationLayer); stationLayer = null; }
        stationLayer = L.geoJSON(data, {
          pointToLayer: (feature, latlng) => L.circleMarker(latlng, { radius: 2, weight: 0.5, color: '#666', fillColor: '#666', fillOpacity: 0.4, interactive: false })
        });
        const pts = data.features.filter(f => f.geometry && f.geometry.type === 'Point');
        populateStationIndex(pts);
        setStatus('Map ready with railway network and train simulation.');
        updateVisibilityForZoom();
        return true;
      });
    }
    function loadStationsFromJson(url) {
      return fetch(url).then(r => { if (!r.ok) throw new Error('not found'); return r.text(); }).then(text => {
        const json = parseJsonLoose(text);
        const arr = Array.isArray(json) ? json : (Array.isArray(json.data) ? json.data : []);
        if (!Array.isArray(arr) || arr.length === 0) throw new Error('empty');
        const fc = makeFeaturesFromArray(arr);
        if (!fc.features.length) throw new Error('no points');
        if (stationLayer) { if (map.hasLayer(stationLayer)) map.removeLayer(stationLayer); stationLayer = null; }
        stationLayer = L.geoJSON(fc, {
          pointToLayer: (feature, latlng) => L.circleMarker(latlng, { radius: 3, weight: 1, color: '#666', fillColor: '#666', fillOpacity: 0.6, interactive: false })
        });
        populateStationIndex(fc.features);
        setStatus('Map ready with railway network and train simulation.');
        updateVisibilityForZoom();
        return true;
      });
    }
    function loadStationsMulti() {
      const candidates = [
        { url: 'station.geojson', kind: 'geojson' },
        { url: 'railway_station.geojson', kind: 'geojson' },
        { url: 'stations.json', kind: 'json' },
        { url: 'New folder/archive/stations.json', kind: 'json' },
      ];
      const tryNext = (i) => {
        if (i >= candidates.length) { setStatus('Failed to load stations from known sources.'); return Promise.reject(new Error('no stations')); }
        const c = candidates[i];
        const loader = c.kind === 'geojson' ? loadStationsFromGeoJSON : loadStationsFromJson;
        return loader(c.url).catch(() => tryNext(i+1));
      };
      return tryNext(0);
    }
    const stationsReady = loadStationsMulti().catch(err => { console.error('Stations load error:', err); });

    // Realtime train positions polling (for trains.json/schedule.json containing lat/lng)
  const realtimeMarkerById = new Map(); // id -> L.marker
  const realtimeSeenAt = new Map(); // id -> timestamp ms last seen
    function guessLatLng(o) {
      const toNum = (v) => { const n = Number(v); return isFinite(n) ? n : null; };
      const lat = toNum(o.lat ?? o.latitude ?? o.Latitude ?? (o.coordinates && o.coordinates[1]) ?? (o.geometry && Array.isArray(o.geometry.coordinates) && o.geometry.coordinates[1]));
      const lng = toNum(o.lng ?? o.lon ?? o.longitude ?? o.Longitude ?? (o.coordinates && o.coordinates[0]) ?? (o.geometry && Array.isArray(o.geometry.coordinates) && o.geometry.coordinates[0]));
      return { lat, lng };
    }
    function guessTrainId(o, idx) { return o.id ?? o.trainId ?? o.train_id ?? o["Train No"] ?? o.train_no ?? o.name ?? `R${idx+1}`; }
    function extractRealtimeArray(json) {
      if (Array.isArray(json)) return json;
      if (json && Array.isArray(json.data)) return json.data;
      if (json && Array.isArray(json.trains)) return json.trains;
      return [];
    }
    function updateRealtimeFrom(payload) {
      const arr = extractRealtimeArray(payload);
      const showByZoom = map.getZoom() >= markerVisibilityZoom;
      arr.forEach((o, i) => {
        let { lat, lng } = guessLatLng(o);
        if (lat != null && lng != null) {
          const snapped = snapLatLngToTrack(lat, lng, 5); // allow up to 5 km to snap
          lat = snapped.lat; lng = snapped.lng;
        }
        if (lat == null || lng == null) return;
        const id = String(guessTrainId(o, i));
        realtimeSeenAt.set(id, Date.now());
        let m = realtimeMarkerById.get(id);
        if (!m) {
          const icon = L.divIcon({ className: 'train-icon', html: 'ðŸš†', iconSize: [20,20] });
          m = L.marker([lat, lng], { icon });
          m.bindTooltip(id, { permanent: true, direction: 'top', offset: [0, -10], className: 'train-label' });
          m.setOpacity(showByZoom ? 1 : 0);
          // Always add to layer group so it appears instantly when user toggles visibility later
          m.addTo(realtimeLayer);
          realtimeMarkerById.set(id, m);
        } else {
          m.setLatLng([lat, lng]);
          m.setOpacity(showByZoom ? 1 : 0);
        }
        if (showTrainMarkers && !map.hasLayer(realtimeLayer)) map.addLayer(realtimeLayer);
        // If a scheduled train with same id exists, temporarily hand over control to realtime
        const t = scheduledTrains.get(id);
        if (t && t.marker) {
          t.externalControlled = true;
          t.externalUntil = Date.now() + 30000; // 30s grace
          if (showTrainMarkers) {
            t.marker.setLatLng([lat, lng]);
            setMarkerVisible(t.marker, showByZoom);
          }
        }
      });
    }
    // Removed startRealtimePolling - using optimized_trains.json simulation only

    // Schedule-driven realtime simulation from train_data files
    function parseHMSToSec(s) {
      if (!s || typeof s !== 'string') return null;
      const m = s.trim().match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
      if (!m) return null;
      const hh = Math.min(23, parseInt(m[1], 10));
      const mm = parseInt(m[2], 10);
      const ss = m[3] ? parseInt(m[3], 10) : 0;
      return hh * 3600 + mm * 60 + ss;
    }
    function nowSecOfDay() {
      const d = new Date();
      return d.getHours()*3600 + d.getMinutes()*60 + d.getSeconds();
    }
    function buildSimTrainFromObj(obj) {
      const id = String(obj['Train No'] ?? obj.train_no ?? obj.id ?? obj['TrainNo'] ?? obj['Train ID'] ?? obj['Train Name'] ?? Math.random().toString(36).slice(2));
      const name = String(obj['Train Name'] ?? obj.name ?? id);
      const route = Array.isArray(obj.Route) ? obj.Route.slice() : [];
      if (!route.length) return null;
      // Sort by SEQ numeric
      route.sort((a,b) => Number(a.SEQ ?? a.seq ?? a.order ?? 0) - Number(b.SEQ ?? b.seq ?? b.order ?? 0));
      const stops = [];
      for (const s of route) {
        const stName = s['Station Name'] ?? s.station_name ?? s.stationName ?? s.station ?? s['Station'];
        const tStr = s['Departure Time'] ?? s['Arrival time'] ?? s.departure_time ?? s.arrival_time;
        const tSec = parseHMSToSec(String(tStr || '').trim());
        if (!stName || tSec == null) continue;
        // Resolve station coordinates
        const rec = resolveStationName(stName);
        if (!rec) { continue; }
        stops.push({ name: stName, lat: rec.lat, lng: rec.lng, t: tSec });
      }
      if (stops.length < 2) return null;
      // Unwrap midnight crossings: ensure non-decreasing times
      for (let i = 1; i < stops.length; i++) {
        if (stops[i].t < stops[i-1].t) {
          const delta = Math.ceil((stops[i-1].t - stops[i].t + 1) / 86400) * 86400;
          for (let j = i; j < stops.length; j++) stops[j].t += delta;
        }
      }
      return { id, name, stops };
    }
    const simTrains = [];
    let simInterval = null;
    // Removed startTrainDataRealtime - using optimized_trains.json simulation only

    // Polyline-based realtime simulation from sample_train_routes.json
    function toLatLngPair(p) {
      if (!Array.isArray(p) || p.length < 2) return null;
      const a = Number(p[1]); // lat
      const b = Number(p[0]); // lng
      if (!isFinite(a) || !isFinite(b)) return null;
      return [a, b];
    }
    function computeCumulativeKm(latlngs) {
      const cum = [0];
      for (let i = 1; i < latlngs.length; i++) {
        const [la1, ln1] = latlngs[i-1];
        const [la2, ln2] = latlngs[i];
        const d = haversineKm(la1, ln1, la2, ln2);
        cum.push(cum[cum.length - 1] + d);
      }
      return { cum, total: cum[cum.length - 1] };
    }
    function posAlongPolyline(latlngs, cum, targetKm) {
      if (!latlngs.length) return null;
      if (targetKm <= 0) return latlngs[0];
      const total = cum[cum.length - 1];
      if (targetKm >= total) return latlngs[latlngs.length - 1];
      let i = 1;
      while (i < cum.length && cum[i] < targetKm) i++;
      const prevKm = cum[i-1];
      const nextKm = cum[i];
      const seg = nextKm - prevKm;
      const r = seg > 0 ? (targetKm - prevKm) / seg : 0;
      const [la1, ln1] = latlngs[i-1];
      const [la2, ln2] = latlngs[i];
      return [la1 + (la2 - la1) * r, ln1 + (ln2 - ln1) * r];
    }
    let sampleSimRoutes = []; // Global so routing functions can access it
    let sampleSimInterval = null;
    function startSampleRoutesRealtime(file = 'sample_train_routes.json') {
      fetch(file)
        .then(r => r.ok ? r.text() : Promise.reject(`HTTP ${r.status}: ${r.statusText}`))
        .then(t => {
          console.log(`Loaded ${file}, size: ${t.length} chars`);
          return parseJsonLoose(t);
        })
        .then(json => {
          if (!json) throw new Error('JSON parsing returned null');
          console.log('Parsed JSON structure:', Object.keys(json));
          
          // Handle different JSON structures
          let trains = [];
          if (Array.isArray(json?.trains)) {
            trains = json.trains;
          } else if (Array.isArray(json)) {
            trains = json;
          } else if (json?.data && Array.isArray(json.data)) {
            trains = json.data;
          } else {
            // Try to find any array property
            for (const [key, value] of Object.entries(json)) {
              if (Array.isArray(value) && value.length > 0) {
                trains = value;
                console.log(`Using array from key: ${key}`);
                break;
              }
            }
          }
          
          if (!trains.length) {
            throw new Error(`No trains array found in JSON. Available keys: ${Object.keys(json || {}).join(', ')}`);
          }
          console.log(`Found ${trains.length} trains in dataset`);
          sampleSimRoutes = [];
          const params = new URLSearchParams(window.location.search);
          const sampleLimit = Number(params.get('sampleLimit') || 50); // Further optimized for smoothness
          let added = 0;
          for (const tr of trains) {
            if (added >= sampleLimit) break;
            const id = String(tr.train_number ?? tr.id ?? tr.trainName ?? Math.random().toString(36).slice(2));
            const name = String(tr.train_name ?? tr.name ?? id);
            // Build polyline: prefer route_coordinates, else from stations
            let coords = [];
            if (Array.isArray(tr.route_coordinates) && tr.route_coordinates.length >= 2) {
              coords = tr.route_coordinates.map(toLatLngPair).filter(Boolean);
            }
            if (coords.length < 2 && Array.isArray(tr.stations)) {
              coords = tr.stations
                .map(s => [Number(s.lat), Number(s.lon)])
                .filter(([la, ln]) => isFinite(la) && isFinite(ln));
            }
            if (coords.length < 2) {
              console.warn(`Skipping train ${id}: insufficient route coordinates`);
              continue;
            }
            const { cum, total } = computeCumulativeKm(coords);
            // Determine timing - be more flexible with time parsing
            let t0 = parseHMSToSec(tr.departure);
            let t1 = parseHMSToSec(tr.arrival);
            if (t0 == null || t1 == null) {
              const st = Array.isArray(tr.stations) ? tr.stations : [];
              const s0 = st.find(s => parseHMSToSec(s.departure) != null);
              const s1 = [...st].reverse().find(s => parseHMSToSec(s.arrival) != null);
              t0 = t0 ?? (s0 ? parseHMSToSec(s0.departure) : null);
              t1 = t1 ?? (s1 ? parseHMSToSec(s1.arrival) : null);
            }
            // If still no times, use default 24-hour cycle for demo
            if (t0 == null || t1 == null) {
              console.warn(`Train ${id}: using default times (no departure/arrival found)`);
              t0 = Math.random() * 86400; // Random start time in 24h
              t1 = t0 + (3600 + Math.random() * 7200); // 1-3 hour journey
            }
            if (t1 <= t0) t1 += 86400; // unwrap midnight
            sampleSimRoutes.push({ id, name, coords, cum, totalKm: total, t0, t1 });
            added++;
            if (added <= 5) { // Log first few trains only
              console.log(`Added train ${id} (${name}) with ${coords.length} route points, ${total.toFixed(1)}km, ${parseFloat((t1-t0)/3600).toFixed(1)}h duration`);
            }
          }
          if (!sampleSimRoutes.length) {
            console.warn('No valid train routes found in sample_train_routes.json');
            setStatus('No valid train routes found');
            return;
          }
          console.log(`Starting simulation with ${sampleSimRoutes.length} trains`);
          let tickCount = 0;
          let frameCount = 0;
          let lastFPSTime = performance.now();
          
          // Performance monitoring
          function updatePerformance(activeTrains) {
            frameCount++;
            const now = performance.now();
            if (now - lastFPSTime >= 1000) {
              const fps = Math.round((frameCount * 1000) / (now - lastFPSTime));
              document.getElementById('fps').textContent = fps;
              document.getElementById('trainCount').textContent = activeTrains;
              frameCount = 0;
              lastFPSTime = now;
            }
          }
          
          const tick = () => {
            const baseNow = nowSecOfDay();
            const showByZoom = map.getZoom() >= markerVisibilityZoom;
            const offsets = [-86400, 0, 86400];
            let activeTrains = 0;
            
            for (const tr of sampleSimRoutes) {
              let pos = null;
              for (const off of offsets) {
                const tNow = baseNow + off;
                if (tNow < tr.t0 || tNow > tr.t1) continue;
                const r = (tNow - tr.t0) / (tr.t1 - tr.t0);
                const targetKm = r * tr.totalKm;
                pos = posAlongPolyline(tr.coords, tr.cum, targetKm);
                // Optimized snapping - less frequent for better performance
                if (pos && (tickCount % 3 === 0 || tr.needsRealign)) {
                  const snapped = snapToTrackStrict(pos[0], pos[1]);
                  pos = [snapped.lat, snapped.lng];
                  tr.needsRealign = false;
                }
                break;
              }
              if (!pos) continue;
              activeTrains++;
              const id = String(tr.id);
              realtimeSeenAt.set(id, Date.now());
              let m = realtimeMarkerById.get(id);
              if (!m) {
                const icon = L.divIcon({ className: 'train-icon', html: 'ðŸš†', iconSize: [20,20] });
                m = L.marker(pos, { icon });
                m.bindTooltip(id, { permanent: true, direction: 'top', offset: [0, -10], className: 'train-label' });
                m.setOpacity(showByZoom ? 1 : 0);
                m.addTo(realtimeLayer);
                realtimeMarkerById.set(id, m);
              } else {
                m.setLatLng(pos);
                m.setOpacity(showByZoom ? 1 : 0);
              }
              if (showTrainMarkers && !map.hasLayer(realtimeLayer)) map.addLayer(realtimeLayer);
              const tState = scheduledTrains.get(id);
              if (tState && tState.marker) {
                tState.externalControlled = true;
                tState.externalUntil = Date.now() + 30000;
                // Optimized DOM updates - only when visible and position changed
                if (showTrainMarkers) {
                  const currentPos = tState.marker.getLatLng();
                  const posChanged = Math.abs(currentPos.lat - pos[0]) > 0.0001 || 
                                    Math.abs(currentPos.lng - pos[1]) > 0.0001;
                  if (posChanged) {
                    tState.marker.setLatLng(pos);
                    setMarkerVisible(tState.marker, showByZoom);
                  }
                }
              }
            }
            
            // Update performance metrics and debug output
            updatePerformance(activeTrains);
            tickCount++;
            if (tickCount % 30 === 0) { // Less frequent logging for better performance
              console.log(`Tick ${tickCount}: ${activeTrains}/${sampleSimRoutes.length} trains active, zoom: ${map.getZoom()}`);
              // Clear distance cache to prevent memory buildup
              if (distanceCache.size > 1000) distanceCache.clear();
            }
          };
          tick();
          if (sampleSimInterval) clearInterval(sampleSimInterval);
          // Use requestAnimationFrame for smoother updates with throttling
          let lastUpdate = 0;
          const targetFPS = 30; // Target 30 FPS
          const frameInterval = 1000 / targetFPS;
          
          function smoothTick() {
            const now = performance.now();
            if (now - lastUpdate >= frameInterval) {
              tick();
              lastUpdate = now;
            }
            sampleSimInterval = requestAnimationFrame(smoothTick);
          }
          smoothTick();
          setStatus(`Main train simulation active from ${file} for ${sampleSimRoutes.length} trains using route coordinates. Routes available for manual routing.`);
        })
        .catch((err) => {
          console.error('Failed to load sample_train_routes.json:', err);
          setStatus('Failed to load main train routes file. Check if sample_train_routes.json exists and is valid JSON.');
        });
    }

    // Once both tracks and stations are in, initialize
    Promise.all([railwayReady, stationsReady]).then(() => {
      updateVisibilityForZoom();
      
      // Load RAILWAY-ALIGNED ultra-optimized trains for realistic simulation
      fetch('ultra_optimized_trains.json')
        .then(r => r.ok ? r.text() : Promise.reject(`HTTP ${r.status}`))
        .then(text => {
          console.log('Loading RAILWAY-ALIGNED ultra-optimized trains (200 schedules, 318KB) - Trains follow actual tracks!');
          return startSampleRoutesRealtime('ultra_optimized_trains.json');
        })
        .catch((err) => {
          console.error('Failed to load ultra_optimized_trains.json, falling back to minimal:', err);
          // Fallback cascade: ultra â†’ minimal â†’ optimized
          return fetch('minimal_trains.json')
            .then(r => r.ok ? r.text() : Promise.reject(`HTTP ${r.status}`))
            .then(text => {
              console.log('Loading fallback minimal trains (150 schedules, 195KB)');
              return startSampleRoutesRealtime('ultra_optimized_trains.json');
            })
            .catch((err2) => {
              console.error('Failed to load ultra_optimized_trains.json, final fallback to optimized_trains.json:', err2);
              return fetch('optimized_trains.json')
                .then(r => r.ok ? r.text() : Promise.reject(`HTTP ${r.status}`))
                .then(text => {
                  console.log('Loading final fallback optimized trains (310 schedules, 0.7MB)');
                  return startSampleRoutesRealtime('optimized_trains.json');
                });
            });
        });
      
      // Apply initial train marker visibility according to UI toggle
      applyTrainMarkerVisibility();
    });
  </script>
</body>
</html>
