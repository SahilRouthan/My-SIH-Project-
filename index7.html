<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>India Railway Router · Start → End on Tracks</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <style>
    #map { height: 100vh; }
    .controls {
      position: absolute;
      z-index: 1000;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.95);
      padding: 10px;
      border-radius: 6px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.15);
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .controls select, .controls button {
      font-size: 14px;
      padding: 6px 8px;
    }
    .status {
      position: absolute;
      z-index: 1000;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 8px 10px;
      border-radius: 6px;
      font-family: system-ui, Arial, sans-serif;
      font-size: 13px;
      max-width: 50ch;
    }
    .train-icon { font-size: 20px; }
    .legend {
      position: absolute;
      z-index: 1000;
      top: 10px;
      right: 10px;
      background: rgba(255,255,255,0.95);
      padding: 8px 10px;
      border-radius: 6px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.15);
      font-family: system-ui, Arial, sans-serif;
      font-size: 12px;
      max-height: 35vh;
      overflow: auto;
    }
    .legend .item { display: flex; align-items: center; gap: 6px; margin: 2px 0; }
    .legend .swatch { width: 12px; height: 12px; border-radius: 2px; border: 1px solid #0002; }
  </style>
</head>
<body>
  <div class="controls">
    <label>From
      <select id="startSelect" disabled>
        <option>Loading stations…</option>
      </select>
    </label>
    <label>To
      <select id="endSelect" disabled>
        <option>Loading stations…</option>
      </select>
    </label>
    <button id="btnFindStart" disabled>Start</button>
    <button id="btnPause" disabled>Pause</button>
    <button id="btnReset" disabled>Reset</button>
    <button id="btnReload" disabled>Reload Schedules</button>
    <button id="btnLoadFile" disabled>Load File…</button>
    <input id="fileInput" type="file" accept=".json,application/json" style="display:none" />
    <label style="margin-left:8px; display:flex; align-items:center; gap:6px;">
      <input id="startNow" type="checkbox" checked />
      <span>Start now</span>
    </label>
  </div>
  <div id="map"></div>
  <div class="status" id="status">Loading railway network…</div>
  <div class="legend" id="legend" hidden>
    <div><strong>Scheduled Trains</strong></div>
    <div id="legendItems"></div>
  </div>

  <script>
    // Initialize map centered on India
    const map = L.map('map').setView([22.8, 79.5], 5);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);

  // Layers and global state
    let railwayLayer = null;
    let stationLayer = null;
    const stationIndex = new Map(); // name -> {lat, lng}
  const stationIndexCi = new Map(); // lowercased name -> {lat, lng}

    // Graph of railway vertices
    const graph = new Map(); // key -> { lat, lng, neighbors: Map(key, distanceKm) }
    const nodeKeys = []; // list of keys for iteration
    const keyOf = (lat, lng) => `${lat.toFixed(5)},${lng.toFixed(5)}`; // dedupe tolerance ~1m-10m

    const toLatLng = (coord) => [coord[1], coord[0]]; // [lng, lat] -> [lat, lng]

    function haversineKm(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function ensureNode(lat, lng) {
      const k = keyOf(lat, lng);
      if (!graph.has(k)) {
        graph.set(k, { lat, lng, neighbors: new Map() });
        nodeKeys.push(k);
      }
      return graph.get(k);
    }

    function addEdge(lat1, lng1, lat2, lng2) {
      const n1 = ensureNode(lat1, lng1);
      const n2 = ensureNode(lat2, lng2);
      const k1 = keyOf(lat1, lng1);
      const k2 = keyOf(lat2, lng2);
      const d = haversineKm(lat1, lng1, lat2, lng2);
      const setMin = (from, to, dist) => {
        const cur = from.neighbors.get(to);
        if (cur === undefined || dist < cur) from.neighbors.set(to, dist);
      };
      setMin(n1, k2, d);
      setMin(n2, k1, d);
    }

    function findNearestNode(lat, lng) {
      let bestKey = null;
      let bestDist = Infinity;
      for (const k of nodeKeys) {
        const n = graph.get(k);
        const d = haversineKm(lat, lng, n.lat, n.lng);
        if (d < bestDist) {
          bestDist = d;
          bestKey = k;
        }
      }
      return { key: bestKey, distKm: bestDist };
    }

    // Min-heap priority queue for Dijkstra
    class MinHeap {
      constructor() { this.a = []; }
      push(item) { this.a.push(item); this.bubbleUp(this.a.length - 1); }
      bubbleUp(i) {
        while (i > 0) {
          const p = Math.floor((i - 1) / 2);
          if (this.a[p][0] <= this.a[i][0]) break;
          [this.a[p], this.a[i]] = [this.a[i], this.a[p]]; i = p;
        }
      }
      pop() {
        if (this.a.length === 0) return undefined;
        const top = this.a[0];
        const end = this.a.pop();
        if (this.a.length > 0) { this.a[0] = end; this.sinkDown(0); }
        return top;
      }
      sinkDown(i) {
        const n = this.a.length;
        while (true) {
          let l = 2*i + 1, r = 2*i + 2, s = i;
          if (l < n && this.a[l][0] < this.a[s][0]) s = l;
          if (r < n && this.a[r][0] < this.a[s][0]) s = r;
          if (s === i) break;
          [this.a[i], this.a[s]] = [this.a[s], this.a[i]]; i = s;
        }
      }
      get length() { return this.a.length; }
    }

    function dijkstra(startKey, endKey) {
      const dist = new Map();
      const prev = new Map();
      const heap = new MinHeap();
      for (const k of nodeKeys) dist.set(k, Infinity);
      dist.set(startKey, 0);
      heap.push([0, startKey]);
      const visited = new Set();

      while (heap.length) {
        const [d, u] = heap.pop();
        if (visited.has(u)) continue;
        visited.add(u);
        if (u === endKey) break;
        const uNode = graph.get(u);
        for (const [v, w] of uNode.neighbors) {
          const nd = d + w;
          if (nd < dist.get(v)) {
            dist.set(v, nd);
            prev.set(v, u);
            heap.push([nd, v]);
          }
        }
      }

      if (!prev.has(endKey) && startKey !== endKey) return null;
      // Reconstruct path
      const path = [];
      let cur = endKey;
      path.push(cur);
      while (cur !== startKey) {
        const p = prev.get(cur);
        if (!p) break; // start==end or no path
        path.push(p);
        cur = p;
      }
      path.reverse();
      return path;
    }

    // UI elements
    const startSelect = document.getElementById('startSelect');
    const endSelect = document.getElementById('endSelect');
    const btnStart = document.getElementById('btnFindStart');
    const btnPause = document.getElementById('btnPause');
    const btnReset = document.getElementById('btnReset');
  const btnReload = document.getElementById('btnReload');
  const btnLoadFile = document.getElementById('btnLoadFile');
  const fileInput = document.getElementById('fileInput');
    const statusEl = document.getElementById('status');

  // Train animation state (manual single route)
    let trainMarker = null;
    let routeLine = null;
    let animTimer = null;
    let paused = false;
    let routeLatLngs = [];
    let segIndex = 0;
    let segOffsetKm = 0;
    const speedKmh = 80; // adjustable speed
    const tickMs = 100;  // update interval

  // Scheduled trains (multiple)
  const scheduledTrains = new Map(); // id -> state
  let scheduledAnimTimer = null;
  let scheduledPaused = false;
  let schedulesLoaded = false;
  const legendEl = document.getElementById('legend');
  const legendItemsEl = document.getElementById('legendItems');
  // Single-track occupancy (undirected edge between two nodes)
  const trackOccupancy = new Map(); // edgeKey -> trainId
  const edgeKeyOf = (k1, k2) => {
    const a = String(k1), b = String(k2);
    return a < b ? `${a}|${b}` : `${b}|${a}`;
  };
  function tryAcquireEdge(trainId, edgeKey) {
    const holder = trackOccupancy.get(edgeKey);
    if (!holder) { trackOccupancy.set(edgeKey, trainId); return true; }
    return holder === trainId;
  }
  function releaseEdge(trainId, edgeKey) {
    const holder = trackOccupancy.get(edgeKey);
    if (holder === trainId) trackOccupancy.delete(edgeKey);
  }

    // Geometry helpers for realistic turning
    function bearingDeg(p1, p2) {
      const y = (p2.lng - p1.lng);
      const x = (p2.lat - p1.lat);
      const ang = Math.atan2(y, x) * 180 / Math.PI; // rough planar
      return (ang + 360) % 360;
    }
    function turnAngleDeg(a, b, c) {
      const br1 = bearingDeg(b, a);
      const br2 = bearingDeg(b, c);
      let d = Math.abs(br2 - br1);
      if (d > 180) d = 360 - d;
      return d; // 0 straight, 180 U-turn
    }

    function setStatus(msg) { statusEl.textContent = msg; }

    function enableUI() {
      startSelect.disabled = false;
      endSelect.disabled = false;
      btnStart.disabled = false;
      btnReload.disabled = false;
      btnLoadFile.disabled = false;
      // If schedules present, allow pause/reset to control them
      if (!schedulesLoaded) {
        btnPause.disabled = true;
        btnReset.disabled = true;
      }
    }

    function populateStationSelects(features) {
      const names = [];
      for (const f of features) {
        const name = f.properties && (f.properties.name ?? f.properties['name:en'] ?? f.properties['Name']);
        if (!name) continue;
        const [lng, lat] = f.geometry.coordinates;
        const rec = { lat, lng };
        stationIndex.set(name, rec);
        stationIndexCi.set(name.toLowerCase().trim(), rec);
        names.push(name);
      }
      names.sort((a,b) => a.localeCompare(b));
      startSelect.innerHTML = '';
      endSelect.innerHTML = '';
      for (const n of names) {
        const o1 = document.createElement('option'); o1.value = n; o1.textContent = n; startSelect.appendChild(o1);
        const o2 = document.createElement('option'); o2.value = n; o2.textContent = n; endSelect.appendChild(o2);
      }
      // Preselect two common stations if present
      if (stationIndex.has('Amritsar Junction')) startSelect.value = 'Amritsar Junction';
      if (stationIndex.has('New Delhi')) endSelect.value = 'New Delhi';
    }

    function buildGraphFromGeoJSON(data) {
      let lineCount = 0, edgeCount = 0;
      const addLine = (coords) => {
        for (let i = 0; i < coords.length - 1; i++) {
          const [lng1, lat1] = coords[i];
          const [lng2, lat2] = coords[i+1];
          addEdge(lat1, lng1, lat2, lng2);
          edgeCount++;
        }
        lineCount++;
      };
      for (const f of data.features) {
        const g = f.geometry;
        if (!g) continue;
        if (g.type === 'LineString') addLine(g.coordinates);
        else if (g.type === 'MultiLineString') {
          for (const part of g.coordinates) addLine(part);
        }
      }
      return { lineCount, edgeCount, nodeCount: nodeKeys.length };
    }

    function resolveStationName(name) {
      if (!name) return null;
      const direct = stationIndex.get(name) || stationIndexCi.get(String(name).toLowerCase().trim());
      if (direct) return direct;
      // Fallback: fuzzy includes match (case-insensitive)
      const needle = String(name).toLowerCase().trim();
      let best = null;
      let bestScore = -Infinity;
      for (const [key, rec] of stationIndex.entries()) {
        const hay = key.toLowerCase();
        if (hay === needle) return rec;
        // score: prefer includes with longer common length and shorter total length difference
        if (hay.includes(needle) || needle.includes(hay)) {
          const common = Math.min(hay.length, needle.length);
          const diff = Math.abs(hay.length - needle.length);
          const score = common * 2 - diff; // heuristic
          if (score > bestScore) { bestScore = score; best = rec; }
        }
      }
      return best;
    }

    function computeRoute(startName, endName) {
      const s = resolveStationName(startName);
      const e = resolveStationName(endName);
      if (!s || !e) { return null; }
      const nearS = findNearestNode(s.lat, s.lng);
      const nearE = findNearestNode(e.lat, e.lng);
      setStatus(`Nearest track nodes: start ${nearS.distKm.toFixed(2)} km, end ${nearE.distKm.toFixed(2)} km away. Finding path…`);
      const pathKeys = dijkstra(nearS.key, nearE.key);
      if (!pathKeys || pathKeys.length === 0) return null;
      return pathKeys.map(k => {
        const n = graph.get(k); return [n.lat, n.lng];
      });
    }

    // Also return node keys so we can manage single-track occupancy
    function computeRouteWithKeys(startName, endName) {
      const s = resolveStationName(startName);
      const e = resolveStationName(endName);
      if (!s || !e) { return null; }
      const nearS = findNearestNode(s.lat, s.lng);
      const nearE = findNearestNode(e.lat, e.lng);
      const keys = dijkstra(nearS.key, nearE.key);
      if (!keys || keys.length === 0) return null;
      const latlngs = keys.map(k => { const n = graph.get(k); return { lat: n.lat, lng: n.lng }; });
      return { keys, latlngs };
    }

    function startAnimation(latlngs) {
      // Cleanup previous
      if (animTimer) { clearInterval(animTimer); animTimer = null; }
      if (routeLine) { map.removeLayer(routeLine); routeLine = null; }
      if (trainMarker) { map.removeLayer(trainMarker); trainMarker = null; }

      if (!latlngs || latlngs.length < 2) { alert('No route to animate.'); return; }

      routeLatLngs = latlngs.map(p => ({ lat: p[0], lng: p[1] }));
      routeLine = L.polyline(routeLatLngs, { color: 'limegreen', weight: 4 }).addTo(map);
      map.fitBounds(routeLine.getBounds(), { padding: [30, 30] });

      const icon = L.divIcon({ className: 'train-icon', html: '🚆', iconSize: [24,24] });
      trainMarker = L.marker(routeLatLngs[0], { icon: icon }).addTo(map);

      segIndex = 0;
      segOffsetKm = 0;
      paused = false;
      btnPause.textContent = 'Pause';
      btnPause.disabled = false;
      btnReset.disabled = false;

      const kmPerTick = speedKmh * (tickMs / 3600000);
      animTimer = setInterval(() => {
        if (paused) return;
        if (segIndex >= routeLatLngs.length - 1) {
          clearInterval(animTimer); animTimer = null; setStatus('Arrived.'); return;
        }
        const a = routeLatLngs[segIndex];
        const b = routeLatLngs[segIndex + 1];
        const segKm = haversineKm(a.lat, a.lng, b.lat, b.lng);
        if (segKm === 0) { segIndex++; segOffsetKm = 0; return; }
        segOffsetKm += kmPerTick;
        if (segOffsetKm >= segKm) {
          segIndex++;
          segOffsetKm = 0;
          trainMarker.setLatLng([b.lat, b.lng]);
        } else {
          const t = segOffsetKm / segKm;
          const lat = a.lat + (b.lat - a.lat) * t;
          const lng = a.lng + (b.lng - a.lng) * t;
          trainMarker.setLatLng([lat, lng]);
        }
        if (segIndex % 50 === 0) { // occasional update
          setStatus(`En route… segment ${segIndex+1}/${routeLatLngs.length-1}`);
        }
      }, tickMs);
    }

    // Utilities for scheduled trains
    function colorForId(id) {
      // Simple hash to HSL color
      let h = 0;
      const s = String(id);
      for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) >>> 0;
      return `hsl(${h % 360} 85% 45%)`;
    }

    // Forgiving JSON parser: handles BOM, comments, trailing commas, and NDJSON fallback
    function parseJsonLoose(text) {
      if (typeof text !== 'string') return text;
      const stripBOM = (t) => t.replace(/^\uFEFF/, '');
      let t = stripBOM(text);
      // First attempt
      try { return JSON.parse(t); } catch (e1) {
        // Remove /* */ and // comments
        try {
          const noBlock = t.replace(/\/\*[\s\S]*?\*\//g, '');
          const noLine = noBlock.replace(/(^|[^:])\/\/.*$/gm, '$1');
          // Remove trailing commas before } or ]
          const noTrailing = noLine.replace(/,\s*([}\]])/g, '$1');
          return JSON.parse(noTrailing);
        } catch (e2) {
          // NDJSON fallback: parse per line
          try {
            const lines = t.split(/\r?\n/).map(l => l.trim()).filter(l => l && !l.startsWith('//'));
            const arr = [];
            for (const line of lines) arr.push(JSON.parse(line));
            return arr;
          } catch (e3) {
            // Give up; rethrow original error with context
            console.error('JSON parse failed:', e1);
            throw e1;
          }
        }
      }
    }

    function parseDepartOffsetMs(val) {
      const now = new Date();
      if (typeof val === 'number' && isFinite(val)) {
        // minutes from now
        return Math.max(0, Math.round(val * 60 * 1000));
      }
      if (typeof val === 'string') {
        // Try ISO or HH:MM[:SS]
        if (/^\d{2}:\d{2}(:\d{2})?$/.test(val)) {
          const [hh, mm, ss] = val.split(':').map(Number);
          const when = new Date(now);
          when.setHours(hh, mm, ss || 0, 0);
          let off = when.getTime() - now.getTime();
          if (off < 0) off += 24 * 60 * 60 * 1000; // next day
          return off;
        }
        const dt = new Date(val);
        if (!isNaN(dt.getTime())) {
          return Math.max(0, dt.getTime() - now.getTime());
        }
      }
      return 0;
    }

    function addLegendItem(id, color, label) {
      const div = document.createElement('div');
      div.className = 'item';
      const sw = document.createElement('span');
      sw.className = 'swatch';
      sw.style.background = color;
      const txt = document.createElement('span');
      txt.textContent = label || String(id);
      div.appendChild(sw); div.appendChild(txt);
      legendItemsEl.appendChild(div);
      legendEl.hidden = false;
    }

    function createScheduledTrain(entry) {
      const id = entry.id ?? entry.trainId ?? entry.name ?? `T${scheduledTrains.size + 1}`;
      const from = entry.from ?? entry.start ?? entry.source ?? entry.startStation;
      const to = entry.to ?? entry.end ?? entry.destination ?? entry.endStation;
      if (!from || !to) {
        console.warn('Schedule missing from/to:', entry);
        return null;
      }
      const routeObj = computeRouteWithKeys(from, to);
      if (!routeObj || routeObj.keys.length < 2) {
        console.warn(`No route for ${id} from ${from} to ${to}`);
        return null;
      }
      const color = entry.color || colorForId(id);
      const speed = Number(entry.speedKmh ?? entry.speed ?? 80);
      const startNowEl = document.getElementById('startNow');
      const startNow = startNowEl ? !!startNowEl.checked : true;
      const departMs = startNow ? 0 : parseDepartOffsetMs(entry.depart ?? entry.departAt ?? entry.departure ?? entry.departureTime ?? 0);
      const latlngObjs = routeObj.latlngs;

      const line = L.polyline(latlngObjs, { color, weight: 3, opacity: 0.9 }).addTo(map);
      const icon = L.divIcon({ className: 'train-icon', html: '🚆', iconSize: [22,22] });
      const marker = L.marker(latlngObjs[0], { icon }).addTo(map);
      marker.bindTooltip(String(id), { permanent: true, direction: 'top', offset: [0, -10], className: 'train-label' });
      // Hide until departure, unless starting immediately
      if (departMs === 0) {
        marker.setOpacity(1);
      } else {
        marker.setOpacity(0);
      }

      const state = {
        id, color, from, to, speedKmh: speed,
        latlngs: latlngObjs,
        keys: routeObj.keys,
        segIndex: 0,
        segOffsetKm: 0,
        marker, line,
        started: departMs === 0,
        completed: false,
        departAt: Date.now() + departMs,
        blockedAtNode: false,
        heldEdgeKey: null,
        turnResumeAt: null,
        turnSlowTicks: 0,
        waitEdgeFromIdx: null,
        pauseNodeIdx: null,
      };
      scheduledTrains.set(id, state);
      addLegendItem(id, color, `${id}: ${from} → ${to}`);
      return state;
    }

    function normalizeSchedulesJson(json) {
      if (Array.isArray(json)) return json;
      if (!json || typeof json !== 'object') return [];
      const known = json.schedules || json.trains || json.entries || json.train_schedules || json.train_schedule || json.data || json.items || json.rows || [];
      if (Array.isArray(known) && known.length) return known;
      // Fallback: pick the longest array-valued property
      let best = [];
      for (const [k, v] of Object.entries(json)) {
        if (Array.isArray(v) && v.length > best.length) best = v;
      }
      return best;
    }

    // Convert various entry shapes into simple trips {id, name, from, to, depart?}
    function deriveTripsFromEntries(entries) {
      if (!Array.isArray(entries)) return [];
      // Case 1: already trips with from/to
      const hasFromTo = entries.some(e => e && (e.from || e.start || e.source || e.startStation) && (e.to || e.end || e.destination || e.endStation));
      if (hasFromTo) return entries;
      const trips = [];
      // Case 2: train objects with Route arrays (your sample)
      const trainsWithRoute = entries.filter(e => e && Array.isArray(e.Route) && e.Route.length > 0);
      if (trainsWithRoute.length) {
        for (const t of trainsWithRoute) {
          const id = t['Train No'] ?? t.train_no ?? t.trainNo ?? t.id ?? t.trainId ?? t['TrainNo'];
          const name = t['Train Name'] ?? t.train_name ?? t.name;
          const stops = t.Route.slice().sort((a,b) => (Number(a.SEQ ?? a.seq ?? a.order ?? 0) - Number(b.SEQ ?? b.seq ?? b.order ?? 0)));
          const first = stops[0];
          const last = stops[stops.length - 1];
          const getStopName = (s) => s && (s['Station Name'] ?? s.station_name ?? s.stationName ?? s.station ?? s['Station']);
          const from = getStopName(first) || t['Source Station Name'] || t.source || t.sourceStation;
          const to = getStopName(last) || t['Destination Station Name'] || t.destination || t.destinationStation;
          const depart = first && (first['Departure Time'] ?? first['Arrival time'] ?? first.departure_time ?? first.arrival_time);
          if (from && to) {
            trips.push({ id, name, from, to, ...(depart ? { depart } : {}) });
          }
        }
        if (trips.length) return trips;
      }
      // Case 3: Unknown structure; pass through
      return entries;
    }

    function createTrainsFromEntries(entries, fit = true) {
      const useEntries = deriveTripsFromEntries(entries);
      let created = 0;
      const bounds = L.latLngBounds([]);
      for (const e of useEntries) {
        const t = createScheduledTrain(e);
        if (t) {
          created++;
          t.latlngs.forEach(p => bounds.extend([p.lat, p.lng]));
        }
      }
      if (created > 0) {
        schedulesLoaded = true;
        btnPause.disabled = false;
        btnReset.disabled = false;
        startScheduledLoop();
        if (fit && bounds.isValid()) map.fitBounds(bounds, { padding: [30,30] });
        setStatus(`Loaded ${created} scheduled train${created>1?'s':''}.`);
      } else {
        setStatus('No valid scheduled trains to show.');
      }
      return created;
    }

    function startScheduledLoop() {
      if (scheduledAnimTimer) return;
      const kmPerTickByTrain = (t) => t.speedKmh * (tickMs / 3600000);
      scheduledAnimTimer = setInterval(() => {
        if (scheduledPaused) return;
        const now = Date.now();
        let activeCount = 0, doneCount = 0, notStarted = 0;
        for (const t of scheduledTrains.values()) {
          if (t.completed) { doneCount++; continue; }
          if (!t.started) {
            if (now >= t.departAt) {
              t.started = true;
              t.marker.setOpacity(1);
            } else {
              notStarted++;
              continue; // not started yet
            }
          }
          activeCount++;
          if (t.segIndex >= t.latlngs.length - 1) { t.completed = true; continue; }
          // Handle node blocking (waiting for lock or turn dwell)
          if (t.blockedAtNode) {
            const nodeIdx = Math.min(t.segIndex, t.latlngs.length - 1);
            if (t.turnResumeAt && now < t.turnResumeAt) {
              const pos = t.latlngs[nodeIdx];
              t.marker.setLatLng([pos.lat, pos.lng]);
              continue;
            }
            if (t.turnResumeAt && now >= t.turnResumeAt) {
              t.turnResumeAt = null;
            }
            // Try to acquire outgoing edge
            if (t.keys && t.keys.length > t.segIndex + 1) {
              const ek = edgeKeyOf(t.keys[t.segIndex], t.keys[t.segIndex + 1]);
              if (tryAcquireEdge(t.id, ek)) {
                t.heldEdgeKey = ek;
                t.blockedAtNode = false;
                t.segOffsetKm = 0;
              } else {
                const pos = t.latlngs[nodeIdx];
                t.marker.setLatLng([pos.lat, pos.lng]);
                continue;
              }
            } else {
              t.completed = true; continue;
            }
          }
          const a = t.latlngs[t.segIndex];
          const b = t.latlngs[t.segIndex + 1];
          const segKm = haversineKm(a.lat, a.lng, b.lat, b.lng);
          if (segKm === 0) { t.segIndex++; t.segOffsetKm = 0; t.marker.setLatLng([b.lat, b.lng]); continue; }
          // Ensure we hold the current edge before moving into it
          if (t.keys && t.keys.length > t.segIndex + 1) {
            const curEk = edgeKeyOf(t.keys[t.segIndex], t.keys[t.segIndex + 1]);
            if (!t.heldEdgeKey || t.heldEdgeKey !== curEk) {
              if (tryAcquireEdge(t.id, curEk)) {
                t.heldEdgeKey = curEk;
              } else {
                // Cannot enter edge, wait at node a
                t.blockedAtNode = true;
                t.segOffsetKm = 0;
                t.marker.setLatLng([a.lat, a.lng]);
                continue;
              }
            }
          }
          const kmStep = kmPerTickByTrain(t) * (t.turnSlowTicks > 0 ? 0.4 : 1);
          if (t.turnSlowTicks > 0) t.turnSlowTicks--;
          t.segOffsetKm += kmStep;
          if (t.segOffsetKm >= segKm) {
            // Arrived at node b
            t.marker.setLatLng([b.lat, b.lng]);
            // Release current edge lock at node arrival
            if (t.heldEdgeKey) { releaseEdge(t.id, t.heldEdgeKey); t.heldEdgeKey = null; }
            const nextStartIdx = t.segIndex + 1;
            if (nextStartIdx >= t.keys.length - 1) {
              t.segIndex = nextStartIdx;
              t.segOffsetKm = 0;
              t.completed = true;
              continue;
            }
            // Assess turn sharpness; if sharp, dwell briefly and slow after
            const prevIdx = Math.max(0, t.segIndex - 1);
            const A = t.latlngs[prevIdx];
            const B = t.latlngs[nextStartIdx];
            const C = t.latlngs[nextStartIdx + 1];
            let sharp = false;
            if (A && B && C) {
              const ang = turnAngleDeg(A, B, C);
              sharp = ang > 120; // threshold
            }
            // Move index to start of next edge and try to acquire
            t.segIndex = nextStartIdx;
            t.segOffsetKm = 0;
            const nextEk = edgeKeyOf(t.keys[nextStartIdx], t.keys[nextStartIdx + 1]);
            if (tryAcquireEdge(t.id, nextEk)) {
              t.heldEdgeKey = nextEk;
              if (sharp) {
                t.blockedAtNode = true;
                t.turnResumeAt = now + 300;
                t.turnSlowTicks = 3;
              }
            } else {
              t.blockedAtNode = true;
            }
          } else {
            const ratio = t.segOffsetKm / segKm;
            const lat = a.lat + (b.lat - a.lat) * ratio;
            const lng = a.lng + (b.lng - a.lng) * ratio;
            t.marker.setLatLng([lat, lng]);
          }
        }
        if ((activeCount + doneCount + notStarted) > 0) {
          setStatus(`Scheduled trains: active ${activeCount}, waiting ${notStarted}, completed ${doneCount}, total ${scheduledTrains.size}`);
        }
      }, tickMs);
    }

    function resetScheduled() {
      if (scheduledAnimTimer) { clearInterval(scheduledAnimTimer); scheduledAnimTimer = null; }
      for (const t of scheduledTrains.values()) {
        if (t.marker) map.removeLayer(t.marker);
        if (t.line) map.removeLayer(t.line);
        if (t.heldEdgeKey) releaseEdge(t.id, t.heldEdgeKey);
      }
      scheduledTrains.clear();
      legendItemsEl.innerHTML = '';
      legendEl.hidden = true;
      scheduledPaused = false;
      schedulesLoaded = false;
      trackOccupancy.clear();
    }

    function loadSchedulesIfAvailable() {
      // Try URL param ?schedule=filename.json first
      const params = new URLSearchParams(window.location.search);
      const paramFile = params.get('schedule');
      const candidates = paramFile ? [paramFile] : ['schedules.json', 'train_schedules.json', 'train_schedule.json'];
      const tryNext = (i) => {
        if (i >= candidates.length) return; // give up silently
        const file = candidates[i];
        fetch(file).then(r => {
          if (!r.ok) throw new Error(`No ${file}`);
          return r.text();
        }).then(text => {
          let json;
          try { json = parseJsonLoose(text); } catch (e) {
            setStatus(`Failed to parse ${file} (invalid JSON). Check console.`);
            console.error(`Failed to parse ${file}:`, e);
            return;
          }
          const entries = normalizeSchedulesJson(json);
          if (!Array.isArray(entries) || entries.length === 0) {
            setStatus(`${file} loaded but empty.`);
            return;
          }
          createTrainsFromEntries(entries, true);
        }).catch(() => tryNext(i+1));
      };
      tryNext(0);
    }

    btnStart.addEventListener('click', () => {
      const s = startSelect.value;
      const e = endSelect.value;
      if (!s || !e || s === e) { alert('Pick two distinct stations.'); return; }
      setStatus('Computing route on tracks…');
      const route = computeRoute(s, e);
      if (!route) { setStatus('No route found between selected stations.'); alert('No railway path found.'); return; }
      startAnimation(route);
      setStatus('Animating on-track route.');
    });

    btnPause.addEventListener('click', () => {
      // Pause/resume both manual and scheduled animations as applicable
      if (animTimer) {
        paused = !paused;
      }
      if (scheduledAnimTimer) {
        scheduledPaused = !scheduledPaused;
      }
      // If either exists, toggle button text; otherwise do nothing
      const isPaused = (animTimer && paused) || (scheduledAnimTimer && scheduledPaused);
      const isRunning = (animTimer && !paused) || (scheduledAnimTimer && !scheduledPaused);
      if (animTimer || scheduledAnimTimer) {
        btnPause.textContent = isPaused ? 'Resume' : 'Pause';
        setStatus(isPaused ? 'Paused.' : (isRunning ? 'Animating…' : 'Ready.'));
      }
    });

    btnReset.addEventListener('click', () => {
      // Reset manual animation
      if (animTimer) { clearInterval(animTimer); animTimer = null; }
      if (routeLine) { map.removeLayer(routeLine); routeLine = null; }
      if (trainMarker) { map.removeLayer(trainMarker); trainMarker = null; }
      segIndex = 0; segOffsetKm = 0; paused = false;
      btnPause.textContent = 'Pause';
      // Reset scheduled trains as well
      resetScheduled();
      btnPause.disabled = true; // until new manual or schedules loaded
      btnReset.disabled = true;
      setStatus('Ready. Choose start and end, then Start. (If schedules.json exists, it will auto-load)');
    });

    btnReload.addEventListener('click', () => {
      // Clear existing scheduled and reload from file
      resetScheduled();
      loadSchedulesIfAvailable();
      btnPause.disabled = false;
      btnReset.disabled = false;
      setStatus('Reloading schedules.json…');
    });

    btnLoadFile.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', () => {
      const f = fileInput.files && fileInput.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const json = parseJsonLoose(reader.result);
          const entries = normalizeSchedulesJson(json);
          resetScheduled();
          createTrainsFromEntries(entries, true);
          btnPause.disabled = false;
          btnReset.disabled = false;
          setStatus(`Loaded ${entries.length} entries from ${f.name}`);
        } catch (e) {
          console.error(e);
          setStatus(`Failed to parse ${f.name}`);
        }
      };
      reader.readAsText(f);
    });
    // Load railway tracks and build graph
    const railwayReady = fetch('Railways_indian.geojson').then(r => r.json()).then(data => {
      railwayLayer = L.geoJSON(data, { style: { color: '#1e88e5', weight: 1 } }).addTo(map);
      const stats = buildGraphFromGeoJSON(data);
      setStatus(`Railway loaded: ${stats.nodeCount.toLocaleString()} nodes, ${stats.edgeCount.toLocaleString()} edges.`);
    }).catch(err => {
      console.error(err); setStatus('Failed to load Railways_indian.geojson');
    });

    // Load stations and populate selects + map
    const stationsReady = fetch('station.geojson').then(r => r.json()).then(data => {
      stationLayer = L.geoJSON(data, {
        pointToLayer: (feature, latlng) => L.circleMarker(latlng, {
          radius: 4, weight: 1, color: '#000', fillColor: 'red', fillOpacity: 0.85
        }).bindPopup(feature.properties && feature.properties.name ? feature.properties.name : 'Station')
      }).addTo(map);
      const pts = data.features.filter(f => f.geometry && f.geometry.type === 'Point');
      populateStationSelects(pts);
      enableUI();
      setStatus('Ready. Choose start and end, then Start. (Looking for schedules.json…)');
    }).catch(err => {
      console.error(err); setStatus('Failed to load station.geojson');
    });

    // Once both tracks and stations are in, try to load schedules.json
    Promise.all([railwayReady, stationsReady]).then(() => {
      loadSchedulesIfAvailable();
    });
  </script>
</body>
</html>